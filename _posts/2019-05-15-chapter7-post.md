---
layout: post
title: "[인사이드 안드로이드] 챕터 7 - 안드로이드 바인더 IPC"
description:
headline:
modified: 2019-05-15
category: Android
tags: [Android]
imagefeature: cover_1.jpg
mathjax:
chart:
comments: true
share: ture
featured: true
---

# [인사이드 안드로이드]


## Chapter7 - 안드로이드 바인더 IPC  


---------------------------------------


### 리눅스 메모리 공간과 바인더 드라이버  

바인더를 이해하려면 먼저 안드로이드의 기반 커널인 리눅스 커널의 메모리 공간을 이해할 필요가 있다. 총 4GB에 달하는 가상 주소 공간은 3GB의 사용자 공간과 1GB의 커널 공간으로 나뉜다. 사용자 코드와 관련 라이브러리는 사용자 공간의 코드 영역, 데이터 영역, 스택 영역에서 동작하고, 커널 공간에서 동작해야 할 코드는 커널 공간의 각 영역에서 동작한다. 그리고 프로세스는 다음과 같이 각자 독립된 주소 공간을 가지고 별개로 동작한다.  

![binder1](/images/post/binder1.png "binder1")  


자신의 독립된 공간을 가진 프로세스가 다른 프로세스에게 **데이터를 전달할 때는 프로세스간 공유가 가능한 커널 공간을 이용한다.** 프로세스는 독립적인 사용자 공간을 가지지만 커널 공간은 공유할 수 있다. 커널 공간을 이용해 두 프로세스 사이의 메시지를 주고 받는 IPC를 수행한다.  

기존 리눅스에서도 IPC 도구를 제공하지만, 안드로이드에서는 단순히 메시지를 전달하는 IPC 개념이 아니라 상대방 프로세스에 존재하는 함수까지 호출할 수 있는 바인더라는 IPC 도구를 채택해 프로세스 간의 RPC를 지원한다.  

바인더는 프로세스들이 사용자 공간을 공유하지 않는다는 제약 조건상에서 프로세스간 통신을 제공하기 위해 다음처럼 커널 공간에서 동작하는 Binder(IPC) Driver라는 추상화된 드라이버를 이용한다.  

![binder2](/images/post/binder2.png "binder2")  

안드로이드에서 바인더 드라이버를 추가해서 프로세스 간 통신을 수행하는 이유는 다음과 같다. 바인더는 사용자 공간에서 접근할 수 없는 공간인 커널 공간을 이용해 **데이터의 신뢰성을 확보**할 수 있으며 **IPC 간의 보안 문제도 동시에 해결**할 수 있다.

### 안드로이드 바인더 모델  
